#include "list.h"                     // Подключение заголовочного файла, содержащего определения для списка
#include <stdio.h>                    // Подключение стандартной библиотеки ввода-вывода
#include <stdlib.h>                   // Подключение стандартной библиотеки для динамического выделения памяти

// Создание нового списка
item_t *list_create(size_t size)     // Функция создания списка, принимает размер данных элементов
{
    item_t *list = malloc(sizeof(item_t)); // Выделение памяти для структуры списка
    list->head = NULL;                     // Инициализация головы списка как NULL
    list->data_size = size;                // Сохранение размера данных элементов
    return list;                           // Возвращение указателя на созданный список
}

// Проверка, пуст ли список
bool list_empty(item_t *list)             // Функция проверки пустоты списка
{
    return list->head == NULL;             // Возвращает true, если голова списка равна NULL
}

// Проверка, содержит ли список заданный элемент
bool list_contains(item_t *list, void *item) // Функция проверки наличия элемента в списке
{
    list_node_t *node = list->head;           // Начало с головного узла
    while (node != NULL)                      // Перебор узлов до конца списка
    {
        if (!memcmp(node->data, item, list->data_size)) // Сравнение данных узла с искомым элементом
            return true;                       // Возвращает true, если найден

        node = node->next;                    // Переход к следующему узлу
    }
    return false;                             // Возвращает false, если элемент не найден
}

// Получение длины списка
size_t list_length(item_t *list)            // Функция получения длины списка
{
    list_node_t *node = list->head;         // Начало с головного узла
    size_t length = 0;                      // Инициализация счетчика длины
    while (node != NULL)                    // Перебор узлов до конца списка
    {
        length++;                           // Увеличение счетчика для каждого узла
        node = node->next;                  // Переход к следующему узлу
    }
    return length;                          // Возврат длины списка
}

// Получение индекса элемента в списке
size_t list_index(item_t *list, void *item) // Функция получения индекса элемента
{
    list_node_t *node = list->head;         // Начало с головного узла
    size_t index = 0;                       // Инициализация индекса
    while (node != NULL)                    // Перебор узлов до конца списка
    {
        if (!memcmp(node->data, item, list->data_size)) // Сравнение данных узла с искомым элементом
            return index;                   // Возвращение индекса, если элемент найден
        index++;                            // Инкремент индекса
        node = node->next;                  // Переход к следующему узлу
    }
    return (size_t)-1;                      // Возвращение -1, если элемент не найден
}

// Удаление последнего элемента из списка и возвращение его данных
void *list_pop(item_t *list)                // Функция удаления последнего элемента
{
    if (list->head == NULL)                 // Проверка, пуст ли список
    {
        return NULL;                        // Возвращение NULL, если список пуст
    }

    if (list->head->next == NULL)           // Проверка, содержит ли список только один элемент
    {
        void *data = list->head->data;      // Получение данных головного узла
        free(list->head);                   // Освобождение памяти головного узла
        list->head = NULL;                  // Установка головы списка в NULL
        return data;                        // Возвращение данных
    }

    list_node_t *current = list->head;      // Начало с головного узла
    while (current->next->next != NULL)     // Перебор до предпоследнего узла
    {
        current = current->next;            // Переход к следующему узлу
    }

    void *data = current->next->data;       // Получение данных последнего узла
    free(current->next);                    // Освобождение памяти последнего узла
    current->next = NULL;                   // Обнуление ссылки на последний узел

    return data;                            // Возвращение данных последнего узла
}

// Добавление нового элемента в конец списка
void list_append(item_t *list, void *item)  // Функция добавления элемента в конец списка
{
    list_node_t *new_node = malloc(sizeof(list_node_t)); // Выделение памяти для нового узла
    if (new_node == NULL)                    // Проверка успешности выделения памяти
    {
        return;                              // Возвращение управления, если память не выделена
    }

    new_node->data = malloc(list->data_size); // Выделение памяти для данных нового узла
    if (new_node->data == NULL)               // Проверка успешности выделения памяти для данных
    {
        free(new_node);                       // Освобождение памяти нового узла, если данные не выделены
        return;                               // Возвращение управления
    }

    memcpy(new_node->data, item, list->data_size); // Копирование данных в новый узел

    new_node->next = NULL;                     // Установка следующего узла в NULL

    if (list->head == NULL)                    // Проверка, пуст ли список
    {
        list->head = new_node;                 // Установка головы списка в новый узел, если список пуст
        return;                                // Возвращение управления
    }
    list_node_t *node = list->head;            // Начало с головного узла
    while (node->next != NULL)                 // Перебор до последнего узла
    {
        node = node->next;                     // Переход к следующему узлу
    }
    node->next = new_node;                     // Установка следующего узла в новый узел
}

// Удаление элемента из списка
void list_remove(item_t *list, void *item)    // Функция удаления элемента из списка
{
    list_node_t *node = list->head;            // Начало с головного узла
    list_node_t *prev = NULL;                  // Инициализация предыдущего узла как NULL
    while (node != NULL)                       // Перебор узлов до конца списка
    {
        if (!memcmp(node->data, item, list->data_size)) // Сравнение данных узла с искомым элементом
        {
            if (prev == NULL)                  // Проверка, является ли текущий узел головным
                list->head = node->next;       // Обновление головы списка, если текущий узел головной
            else
                prev->next = node->next;       // Обновление ссылки на следующий узел в предыдущем узле

            free(node->data);                  // Освобождение памяти данных узла
            free(node);                        // Освобождение памяти узла
            return;                            // Возвращение управления после удаления узла
        }
        prev = node;                           // Обновление предыдущего узла
        node = node->next;                     // Переход к следующему узлу
    }
}

// Вставка элемента в указанную позицию в списке
void list_insert(item_t *list, size_t index, void *item) // Функция вставки элемента по индексу
{
    if (list == NULL || item == NULL)          // Проверка на NULL указатели аргументов
        return;                                // Возвращение управления, если аргументы некорректны

    list_node_t *new_node = malloc(sizeof(list_node_t)); // Выделение памяти для нового узла
    if (new_node == NULL)                      // Проверка успешности выделения памяти
        return;                                // Возвращение управления, если память не выделена

    new_node->data = malloc(list->data_size);  // Выделение памяти для данных нового узла
    if (new_node->data == NULL)                // Проверка успешности выделения памяти для данных
    {
        free(new_node);                        // Освобождение памяти нового узла, если данные не выделены
        return;                                // Возвращение управления
    }
    memcpy(new_node->data, item, list->data_size); // Копирование данных в новый узел

    if (index == 0 || list->head == NULL)      // Проверка, нужно ли вставить элемент в начало списка
    {
        new_node->next = list->head;           // Установка следующего узла нового узла в головной узел
        list->head = new_node;                 // Обновление головного узла списка
    }
    else
    {
        list_node_t *current = list->head;     // Начало с головного узла
        size_t i = 0;                          // Инициализация счетчика индекса
        while (current->next != NULL && i < index - 1) // Перебор узлов до достижения позиции вставки
        {
            current = current->next;           // Переход к следующему узлу
            i++;                               // Инкремент счетчика индекса
        }
        new_node->next = current->next;        // Установка следующего узла нового узла в следующий узел текущего
        current->next = new_node;              // Обновление ссылки на следующий узел текущего узла
    }
}

// Уничтожение списка и освобождение памяти всех узлов
void list_destroy(item_t *list)               // Функция уничтожения списка
{
    list_node_t *node = list->head;           // Начало с головного узла
    while (node != NULL)                      // Перебор узлов до конца списка
    {
        list_node_t *next = node->next;       // Сохранение ссылки на следующий узел
        free(node->data);                     // Освобождение памяти данных узла
        free(node);                           // Освобождение памяти узла
        node = next;                          // Переход к следующему узлу
    }
    free(list);                               // Освобождение памяти структуры списка
}

// Печать списка с целочисленными данными в указанный поток
void list_print_int(item_t *list, FILE *out)  // Функция печати списка в файл
{
    if (list->head == NULL)                   // Проверка, пуст ли список
    {
        fprintf(out, "NULL");                 // Вывод "NULL", если список пуст
        return;                               // Возвращение управления
    }
    list_node_t *node = list->head;           // Начало с головного узла
    while (node != NULL)                      // Перебор узлов до конца списка
    {
        fprintf(out, "(%d)", *(int *)node->data); // Вывод данных узла в формате (число)
        if (node->next != NULL)               // Проверка, есть ли следующий узел
        {
            fprintf(out, " -> ");             // Вывод стрелки, указывающей на следующий элемент
        }
        else
        {
            fprintf(out, " -> NULL");         // Вывод " -> NULL" в конце списка
        }
        node = node->next;                    // Переход к следующему узлу
    }
}
